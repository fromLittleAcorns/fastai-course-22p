# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/05_Datasets_and_Plotting.ipynb.

# %% ../nbs/05_Datasets_and_Plotting.ipynb 1
from __future__ import annotations
import pickle,gzip,math,os,time,shutil,torch,matplotlib as mpl,numpy as np,matplotlib.pyplot as plt
from pathlib import Path
from operator import itemgetter
from itertools import zip_longest
import fastcore.all as fc

from torch import tensor,nn,optim
from torch.utils.data import DataLoader,default_collate
import torch.nn.functional as F

from datasets import load_dataset,load_dataset_builder

# %% auto 0
__all__ = ['inplace', 'collate_dict', 'show_image', 'subplots', 'get_grid', 'show_images']

# %% ../nbs/05_Datasets_and_Plotting.ipynb 36
def inplace(f):
    """ This function allows a function that does not return anything directly (ie one that modifies things
    without a return statenent) to then be used in an application that required a return.  Do this function
    is a wrapper of another function that simply executes the function and then returns the modified input
    """
    def _f(b):
        f(b)
        return b
    return _f

# %% ../nbs/05_Datasets_and_Plotting.ipynb 52
def collate_dict(ds):
    """ when a dataset is defined by a dictionary this will identify the features and split into inputs and outputs
    as tensor arrays ready for input to a model
    """
    get = itemgetter(*ds.features)
    def _f(b): 
        # return a tuple containing the values associated with each of the keys returned by the itemgetter
        # given that default_collate return a dict with two keys and a stacked tensor for each
        return get(default_collate(b))
    return _f

# %% ../nbs/05_Datasets_and_Plotting.ipynb 62
@fc.delegates(plt.Axes.imshow)
def show_image(img, ax=None, title=None, noframe=True, figsize=None, **kwargs):
    # prepare images.  Check if pytorch tensor by using attributes
    if fc.hasattrs(img, ('cpu', 'permute', 'detach')):
        img = img.detach().cpu()
        if len(img.shape)==3 and img.shape[0]<8:
            img = img.permute(1,2,0)
        elif not isinstance(img, np.ndarray):
            img = np.asarray(img)
    # If only one channel remove the dimension
    if img.shape[-1] == 1:
        img = img[...,0]
    # if axes do not exist then create them
    if ax is None: _,ax = plt.subplots(figsize=figsize)
    # plot the array
    ax.imshow(img, **kwargs)
    # Add a title
    if title is not None: ax.set_title(title)
    # turn off tick marks
    ax.set_xticks([])
    ax.set_yticks([])
    # Finally set whether or not to show a frame
    if noframe:
        ax.axis('off')
    return ax

# %% ../nbs/05_Datasets_and_Plotting.ipynb 69
@fc.delegates(plt.subplots, keep=True)
def subplots(
    nrows: int=1, # Number of rows
    ncols: int=1, # Number of columns
    figsize: tuple =None, #Size of overall figure that will be produced in default units
    imsize: float = 3, # size of individual images in default units
    suptitle: str = None, # Title for the plot
    **kwargs
    ) -> (plt.Figure, plt.Axes):
    """ create grid of axes ready for assignment of images to each axis

        nrows (int): number of rows
        ncols (int): number of columns
        figsize (Tuple[float, float]): Size of overall figure that will be produced in default units
        imsize (float): size of individual images in default units
        suptitle (Union[str, None]): title for the overall figure


        fig: plt.Figure
        ax: np.array(plt.Axes)
    """
    # calculate fig size if not supplied
    if figsize is None:
        figsize = (ncols*imsize, nrows*imsize)
    fig, ax = plt.subplots(nrows=nrows, ncols=ncols, figsize=figsize, **kwargs)
    if suptitle is not None: fig.suptitle(suptitle)

    # If only one axes then turn into a array to allow consistent processing (multiple axes are stored as arrays)
    if ncols*nrows==1: ax=array([ax])
    return fig, ax  

# %% ../nbs/05_Datasets_and_Plotting.ipynb 76
@fc.delegates(subplots)
def get_grid(
    n: int, # Number of axes
    nrows: int=None, # Number of rows
    ncols: int=None, # Number of columns
    title: str=None, # Plot title, optional
    weight: str='bold', # Weight to apply to the title
    size: int=14, # size of the title font
    **kwargs
    
):
    # "Return a grid of n axes over a combination of rows and columns."
    # If the rows are specified then ncols will be used if specified but if not then the columns needed
    # will be calculated.  Note that "or" will return the first value unless it is None, when it returns 
    # the second
    if nrows: ncols = ncols or int(np.ceil(n/nrows))
    elif ncols: nrows = int(np.ceil(n/ncols))
    else:
        nrows = int(np.ceil(math.sqrt(n)))
        ncols = int(np.ceil(n/nrows))
    _ = kwargs.pop('cmap', None)
    # Avoid passing cmap to subplots
    fig, axs = subplots(nrows, ncols, **kwargs)
    # Turn of the display of axis
    for i in range(n, nrows*ncols): axs.flat[i].set_axis_off()
    # Add the title if necessary
    if title: 
        fig.suptitle(title, weight=weight, size=size)
    return fig, axs

# %% ../nbs/05_Datasets_and_Plotting.ipynb 79
@fc.delegates(subplots)
def show_images(
    imgs: list, # List of images to show
    nrows: int=1, # Number of rows
    ncols: int=None, # Number of columns
    titles: str=None, # Plot title, optional, list of titles for each image
    **kwargs
):
    # Create a grid of axes ready to plot the images
    axs = get_grid(len(imgs), **kwargs)[1].flat
    # import pdb; pdb.set_trace()
    # Remove unwanted kwargs
    _ = kwargs.pop('imsize', None)
    _ = kwargs.pop('title', None)
    # plot images and individual labels
    for img, t, ax in zip_longest(imgs, titles or [], axs[:len(imgs)]):
        show_image(img, ax, t, **kwargs)
    
